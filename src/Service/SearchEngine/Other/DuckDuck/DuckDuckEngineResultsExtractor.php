<?php

namespace SearchEngineProvider\Service\SearchEngine\Other\DuckDuck;

use SearchEngineProvider\Constants\RegexpConstants;
use SearchEngineProvider\Dto\SearchEngine\SearchEngineResultDto;
use SearchEngineProvider\Exception\SearchEngine\NoSearchResults;

/**
 * Handles extracting the search results from some "js" file that seems to be generated by the DuckDuck backend,
 * This is probably to prevent ppl from easy scrapping the engine results.
 *
 * The way that the {@see SearchEngineResultDto} is being built needs to be dynamic because it's highly possible
 * that upon time keys present in the json will change as this is generated via backend logic
 */
class DuckDuckEngineResultsExtractor
{
    private const REGEX_MATCH_SEARCH_RESULTS = "DDG\.inject\('DDG\.Data\.languages\.adLanguages', \{\}\);if \(DDG\.pageLayout\) DDG\.pageLayout\.load\('.*?',(?<RESULTS>.*?)\);DDG\.duckbar\.load";

    private const RESULT_ARRAY_SIZE_PERCENT_MAX_DIFF = 70;

    private const NO_RESULTS_FOUND_FOR_STRING_INDICATOR = "EOF";

    public function __construct(
        private readonly DuckDuckEngineUrlBuilder $duckDuckEngineUrlBuilder
    ){}

    /**
     * @param string $pageContent
     * @param string $searchedString
     * @param string $vqdToken
     *
     * @return SearchEngineResultDto[]
     * @throws NoSearchResults
     */
    public function extractSearchResults(string $pageContent, string $searchedString, string $vqdToken): array
    {
        $calledUrl = $this->duckDuckEngineUrlBuilder->buildCalledUrlForResults($searchedString, $vqdToken);

        preg_match("#" . self::REGEX_MATCH_SEARCH_RESULTS . "#", $pageContent, $matches);
        $searchResultJsons  = $matches['RESULTS'] ?? "[]";
        $searchResultArrays = json_decode($searchResultJsons, true);

        $this->checkNoResults($searchResultArrays, $searchedString, $calledUrl);

        $filteredResultArrays = $this->filterResultsArray($searchResultArrays);
        $allSearchResults     = [];
        foreach ($filteredResultArrays as $searchResultArray) {
            $allSearchResults[] = $this->handleSingleSearchResult($searchResultArray, $searchedString);
        }

        return $allSearchResults;
    }

    /**
     * Will attempt to build the standardized {@see SearchEngineResultDto} for result array
     *
     * @param array  $resultData
     * @param string $searchedString
     *
     * @return SearchEngineResultDto
     */
    private function handleSingleSearchResult(array $resultData, string $searchedString): SearchEngineResultDto
    {
        $longestValue = ""; // the description with title etc. is always the longest string in array
        $foundUrl     = "";
        $hasFoundUrl  = false;
        $searchResult = new SearchEngineResultDto();

        foreach ($resultData as $valueInArray) {

            // can happen if the data in result array is for snippet with tabs / map etc.
            if (!is_scalar($valueInArray)) {
                continue;
            }

            if (strlen($valueInArray) > strlen($longestValue)) {
                $longestValue = $valueInArray;
            }

            // these strange delimiters are MUST due to the regexp structure
            preg_match("<" . RegexpConstants::REGEX_MATCH_URL_IN_STRING . ">", $valueInArray, $matches);

            if (
                        !$hasFoundUrl
                    &&  isset($matches["URL"])
                    &&  !str_contains($matches["URL"], "@") // because regexp can also catch email
                    &&  filter_var($matches["URL"], FILTER_VALIDATE_URL)
            ) {
                $foundUrl    = trim(strip_tags($matches["URL"]));
                $hasFoundUrl = !empty($foundUrl);
            }
        }

        $arrayKeys = array_keys($resultData);
        $titleKey  = $arrayKeys[count($arrayKeys) - 2] ?? ""; // -2 because count starts from 1, array size from 0,
        $title     = $resultData[$titleKey];
        $cleanUrl  = $this->cleanUrl($foundUrl);

        // it's generally possible to extract the title but highly likely it won't be used anyway
        $searchResult->setDescription($longestValue);
        $searchResult->setLink($cleanUrl);
        $searchResult->setEngineUrl($this->duckDuckEngineUrlBuilder->getBaseUrl());
        $searchResult->setSearchedString($searchedString);
        $searchResult->setTitle($title);

        return $searchResult;
    }

    /**
     * Will return the avg length/size of the array,
     * That is needed as the single data array from results can sometimes have different length/size
     * as other have, and that is wrong - that's probably some meta information for the search engine itself
     *
     * @param array $allSearchResults
     *
     * @return int
     */
    private function getAvgDataArraySize(array $allSearchResults): int
    {
        $dataSizesCount = [];
        foreach ($allSearchResults as $searchResult) {
            $size = count($searchResult);
            if (!array_key_exists($size, $dataSizesCount)) {
                $dataSizesCount[$size] = 1;
                continue;
            }

            $dataSizesCount[$size]++;
        }

        $mostCount = max($dataSizesCount);
        $avgSize   = array_search($mostCount, $dataSizesCount);

        return $avgSize;
    }

    /**
     * Will filter out the search results by removing these that have:
     * - size/length above threshold,
     * - size/length below threshold,
     *
     * It's not fully know what some results are:
     * - maybe ads,
     * - maybe some internal search engine urls,
     *
     * @param array $searchResultArrays
     *
     * @return array
     */
    private function filterResultsArray(array $searchResultArrays): array
    {
        $avgArraySize         = $this->getAvgDataArraySize($searchResultArrays);
        $filteredResultArrays = [];

        $minExclusionValue = self::RESULT_ARRAY_SIZE_PERCENT_MAX_DIFF * $avgArraySize / 100;
        $maxExclusionValue = (100 + self::RESULT_ARRAY_SIZE_PERCENT_MAX_DIFF) * $avgArraySize / 100;

        foreach ($searchResultArrays as $singleResultArray) {
            $currentResultLength = count($singleResultArray);

            if (
                    $currentResultLength < $minExclusionValue
                ||  $currentResultLength > $maxExclusionValue
            ){
                continue;
            }

            $filteredResultArrays[] = $singleResultArray;
        }

        return $filteredResultArrays;
    }

    /**
     * Will clean url from:
     * - new lines,
     * - tabs,
     * - leading / trailing new lines
     *
     * @param string $url
     *
     * @return string
     */
    private function cleanUrl(string $url): string
    {
        $url = preg_replace('#(?<TAB>\t+)|(?<NEW_LINE_ONE>\r)|(?<NEW_LINE_TWO>\n)#', '', $url);
        $url = trim($url);

        return $url;
    }

    /**
     * Check if the `no results found` message is returned, or if there are no results at all (engine configuration changed etc.)
     *
     * @param array  $resultsArray
     * @param string $searchedString
     * @param string $calledUrl
     *
     * @throws NoSearchResults
     */
    private function checkNoResults(array $resultsArray, string $searchedString, string $calledUrl): void
    {
        // no results at all - unknown reason
        if (empty($resultsArray)) {
            throw new NoSearchResults(
                DuckDuckEngineService::ENGINE_NAME,
                $searchedString,
                NoSearchResults::STATUS_NO_SEARCH_RESULTS_RETURNED,
                $calledUrl
            );
        }

        if (count($resultsArray) !== 1) {
            return;
        }

        $firstResult = $resultsArray[array_key_first($resultsArray)];
        foreach ($firstResult as $dataRow) {
            if ($dataRow === self::NO_RESULTS_FOUND_FOR_STRING_INDICATOR) {
                throw new NoSearchResults(
                    DuckDuckEngineService::ENGINE_NAME,
                    $searchedString,
                    NoSearchResults::STATUS_ENGINE_RESPONDED_WITH_NO_RESULTS_MESSAGE,
                    $calledUrl
                );
            }
        }
    }
}